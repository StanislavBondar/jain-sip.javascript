<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: WebRtcCommClient.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: WebRtcCommClient.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @class WebRtcCommClient
 * @classdesc Main object of the WebRtcComm framework providing high level communication service: call and be call
 * @constructor
 * @property {string} id Client identifier
 * @property {object} configuration  client configuration
 * @public
 * @param  {object} eventListener event listener object implementing WebRtcCommClient interface
 */ 
WebRtcCommClient = function(eventListener)
{ 
    if(typeof eventListener == 'object')
    {
        this.id = "WebRtcCommClient" + Math.floor(Math.random() * 2147483648);
        console.debug("WebRtcCommClient:WebRtcCommClient():this.id="+this.id);
        this.eventListener = eventListener; 
        this.configuration=undefined;
        this.connector=undefined;
        this.closePendingFlag=false;
    }
    else 
    {
        throw "WebRtcCommClient:WebRtcCommClient(): bad arguments"      
    }
} 


/**
 * SIP Call Control protocol constant
 * @private
 * @constant
 */ 
WebRtcCommClient.prototype.SIP="SIP"


/**
 * Get opened status
 * @public
 * @returns {boolean} true is opened, false otherise
 */
WebRtcCommClient.prototype.isOpened=function(){
    if(this.connector) return this.connector.isOpened();
    else return false;   
}


/**
 * Open the WebRTC communication client, asynchronous action, requires the WebRtcCommClient
 * interface implementation to be notified of the opened event
 * @public 
 * @param {object} configuration  WebRTC communication client configuration &lt;br>
 *     configuration sample:&lt;br> 
 *     { &lt;br>
 *       communicationMode:WebRtcCommClient.prototype.SIP,&lt;br>
 *       sip:{&lt;br>
 *           sipUserAgent:"WebRtcCommTestWebApp/0.0.1",&lt;br>
 *           sipOutboundProxy:this.DEFAULT_SIP_OUTBOUND_PROXY,&lt;br>
 *           sipDomain:this.DEFAULT_SIP_DOMAIN,&lt;br>
 *           sipUserName:this.DEFAULT_SIP_USER_NAME,&lt;br>
 *           sipLogin:this.DEFAULT_SIP_LOGIN,&lt;br>
 *           sipPassword:this.DEFAULT_SIP_PASSWORD,&lt;br>
 *           sipApplicationProfile:this.DEFAULT_SIP_APPLICATION_PROFILE,&lt;br>
 *           sipRegisterMode:this.DEFAULT_SIP_REGISTER_MODE&lt;br>
 *       },&lt;br>
 *       rtcPeerConnection:&lt;br>
 *       {
 *           stunServer:undefined    &lt;br>     
 *       } &lt;br>
 *      }&lt;br>
 * @throw {String} Exception "bad argument, check API documentation"
 * @throw {String} Exception "bad configuration, missing parameter"
 * @throw {String} Exception "bad state, unauthorized action"
 * @throw {String} Exception internal error
 */
WebRtcCommClient.prototype.open=function(configuration){
    console.debug("WebRtcCommClient:open()");
    if(typeof(configuration) == 'object')
    {
        if(this.isOpened()==false)
        {
            if(this.checkConfiguration(configuration)==true)
            {
                this.configuration=configuration;
                if(configuration.communicationMode==WebRtcCommClient.prototype.SIP)
                {
                    this.connector = new PrivateJainSipClientConnector(this);
                    this.connector.open(this.configuration.sip);
                }
            } 
            else
            {
                console.error("WebRtcCommClient:open(): bad configuration");
                throw "WebRtcCommClient:open(): bad configuration";   
            }
        }
        else
        {   
            console.error("WebRtcCommClient:open(): bad state, unauthorized action");
            throw "WebRtcCommClient:open(): bad state, unauthorized action";    
        }
    }
    else
    {   
        console.error("WebRtcCommClient:open(): bad argument, check API documentation");
        throw "WebRtcCommClient:open(): bad argument, check API documentation"    
    } 
}

/**
 * Close a WebRTC communication client, asynchronous action, requires the WebRtcCommClient
 * listener interface implementation to be notified of the closed event
 * @public 
 * @throw String Exception "bad argument, check API documentation"
 * @throw String Exception "bad configuration, missing parameter"
 * @throw String Exception "bad state, unauthorized action"
 */ 
WebRtcCommClient.prototype.close=function(){
    console.debug("WebRtcCommClient:close()");
    if(this.isOpened())
    {    
        try
        {
            this.closePendingFlag=true;
            this.connector.close();
        }
        catch(exception){
            console.error("WebRtcCommClient:close(): catched exception:"+exception);
            // Force notification of closed event
            this.closePendingFlag=false;
            this.connector=undefined;
            var that=this;
            setTimeout(function(){
                that.webRtcCommClient.eventListener.onWebRtcCommClientClosed(that);
            },1);
        } 
    }
}
 
/**
 * Request a WebRTC communication, asynchronous action, requires the WebRtcCommCall 
 * listener interface implementation to be notified of the closed event 
 * @public 
 * @param {string} calleePhoneNumber Callee contact identifier (Tel URI, SIP URI, etc.)
 * @param {object} callConfiguration Communication configuration
 *     &lt;p>Communication configuration sample: 
 *     &lt;p>var callConfiguration = {
 *               displayedName:this.DEFAULT_SIP_DISPLAY_NAME,
 *               localMediaStream: this.localAudioVideoMediaStream,
 *               audioMediaFlag:this.view.getAudioMediaValue(),
 *               videoMediaFlag:this.view.getVideoMediaValue(),
 *               dataMediaFlag:false
 *     }
 *     &lt;/p>
 *     &lt;/p>
 * @throw String Exception "bad argument, check API documentation"
 * @throw String Exception "bad configuration, missing parameter"
 * @throw String Exception "bad state, unauthorized action"
 */ 
WebRtcCommClient.prototype.call=function(calleePhoneNumber, callConfiguration){
    console.debug("WebRtcCommClient:call():calleePhoneNumber="+calleePhoneNumber);
    console.debug("WebRtcCommClient:call():callConfiguration="+callConfiguration);
    try
    {
        if(typeof(calleePhoneNumber) == 'string' && typeof(callConfiguration) == 'object')
        {
            if(this.isOpened())
            {       
                var newWebRtcCommCall = new WebRtcCommCall(this);
                newWebRtcCommCall.connector=this.connector.createCallConnector(newWebRtcCommCall); 
                newWebRtcCommCall.open(calleePhoneNumber, callConfiguration);
                return newWebRtcCommCall;
            }
            else
            {   
                console.error("WebRtcCommClient:call(): bad state, unauthorized action");
                throw "WebRtcCommClient:call(): bad state, unauthorized action";    
            }
        }
        else
        {   
            console.error("WebRtcCommClient:call(): bad argument, check API documentation");
            throw "WebRtcCommClient:call(): bad argument, check API documentation"    
        }
    }
    catch(exception){
        console.error("WebRtcCommClient:call(): catched exception:"+exception);
        throw exception;  
    }  
}


/**
 * Check client configuration provider by the user
 * @private
 * @param {object} configuration client configuration
 * @returns {boolean} true configuration ok false otherwise
 */ 
WebRtcCommClient.prototype.checkConfiguration=function(configuration){
    console.debug("WebRtcCommClient:checkConfiguration()");
    if(configuration.communicationMode!=undefined)
    {
        if(configuration.communicationMode==WebRtcCommClient.prototype.SIP) 
        {
            return true
        }
    }
    return false;
}

/**
  * Implements ClientConnector listener interface
  * @callback PrivateClientConnector interface
  * @private
  */
WebRtcCommClient.prototype.onClientConnectorOpenedEvent=function()
{
    console.debug ("WebRtcCommClient:onClientConnectorOpenedEvent()");
    if(this.eventListener.onWebRtcCommClientOpenedEvent!=undefined) 
    {
        try{
            this.eventListener.onWebRtcCommClientOpenedEvent();
        } 
        catch(exception){
            console.error("WebRtcCommClient:onClientConnectorOpenedEvent(): catched exception in event listener:"+exception);
        }   
    }
}

/**
  * Implements ClientConnector listener interface
  * @callback PrivateClientConnector interface
  * @private
  */
WebRtcCommClient.prototype.onClientConnectorOpenErrorEvent=function(error)
{
    console.debug ("WebRtcCommClient:onClientConnectorOpenErrorEvent():error:"+error); 
    if(this.eventListener.onWebRtcCommClientOpenErrorEvent!=undefined) 
    {
        try{
            this.eventListener.onWebRtcCommClientOpenErrorEvent();
        } 
        catch(exception){
            console.error("WebRtcCommClient:onClientConnectorOpenErrorEvent(): catched exception in event listener:"+exception);
        } 
        // Close properly the client in anycase
        try {
            this.close();
        } catch(exception) {}
    }
} 
    
/**
  * Implements ClientConnector listener interface
  * @callback PrivateClientConnector interface
  * @private
  */

WebRtcCommClient.prototype.onClientConnectorClosedEvent=function()
{
    console.debug ("WebRtcCommClient:onClientConnectorClosedEvent()");
       
    // Close properly the client
    try {
        if(this.closePendingFlag==false) this.close();
        else  this.connector=undefined;
    } catch(exception) {     
    }
    
    if(this.eventListener.onWebRtcCommClientClosedEvent!=undefined) 
    {
        try{
            this.eventListener.onWebRtcCommClientClosedEvent();
        } 
        catch(exception){
            console.error("WebRtcCommClient:onClientConnectorClosedEvent(): catched exception in event listener:"+exception);
        }   
    }
}




    
    
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-WebRtcComm.html">WebRtcComm</a></li></ul><h3>Classes</h3><ul><li><a href="32c9aa3017.html">PrivateJainSipCallConnector</a></li><li><a href="PrivateJainSipClientConnector.html">PrivateJainSipClientConnector</a></li><li><a href="WebRtcCommCall.html">WebRtcCommCall</a></li><li><a href="WebRtcCommClient.html">WebRtcCommClient</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Fri Feb 15 2013 17:28:30 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
</body>
</html>
